<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <title>闭包 | JS</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/assets/css/0.styles.4ba1a2d2.css" as="style"><link rel="preload" href="/assets/js/app.8cad83db.js" as="script"><link rel="preload" href="/assets/js/4.ec535a3a.js" as="script"><link rel="preload" href="/assets/js/8.ca727292.js" as="script"><link rel="prefetch" href="/assets/js/2.ac86bad6.js"><link rel="prefetch" href="/assets/js/3.36fe6f2b.js"><link rel="prefetch" href="/assets/js/5.c9f25586.js"><link rel="prefetch" href="/assets/js/6.6ea11848.js"><link rel="prefetch" href="/assets/js/7.97ccd650.js"><link rel="prefetch" href="/assets/js/9.479d0db9.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4ba1a2d2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-v-6cecd4a2><header class="header" data-v-6cecd4a2><div class="category" data-v-6cecd4a2><a href="/blog" data-v-6cecd4a2>Blog</a> <a href="/think" data-v-6cecd4a2>Think</a></div></header> <div class="content" data-v-6cecd4a2><div class="content__default" data-v-6cecd4a2><h2 id="作用域和闭包">作用域和闭包</h2> <p>作用域和闭包是JS中非常重要的概念，两者又是密不可分的，理解闭包必须从理解作用域开始</p> <h3 id="作用域是什么">作用域是什么</h3> <p>作用域是一套规则，这套规则规定了变量存储在哪？程序需要时如何找到它们？</p> <p>作用域有两种主要的工作模型，第一种最为普遍，被大多数编程语言所采用的词法作用域，JS正式采用的词法作用域。另一种叫做动态作用域，仍有一些编程语言在使用，比如Bash脚本</p> <p>理解词法作用域需要知道编译原理，一段源代码在执行前会经历三个步骤，统称为编译</p> <ul><li>分词/词法分析（Tokenizing/Lexing）</li></ul> <blockquote><p>这个过程会将由字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元，例如：var a = 2; 这行代码通常会被分解成下面词法单元：var、a、=、2、;。</p></blockquote> <ul><li>解析/语法分析（Parsing）</li></ul> <blockquote><p>这个过程是将词法单元转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，这个树被称为 “抽象语法树”（Abstract Syntax Tree, AST）</p></blockquote> <ul><li>代码生成</li></ul> <blockquote><p>将AST转换为可执行代码的过程被称为代码生成。这个过程于语言、目标平台等信息相关。</p></blockquote> <p>简单来说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此词法分析处理代码时会保持作用域不变</p> <h3 id="小试牛刀">小试牛刀</h3> <p>考虑以下代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> a <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">bar</span><span class="token punctuation">(</span>b <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2, 4, 12</span>
</code></pre></div><p>在这个例子中有三个逐级嵌套的作用域。</p> <ol><li>全局作用域，只有一个标识符：foo</li> <li>foo创建的作用域，其中有三个标识符：a, bar, 和 b</li> <li>bar所创建的作用域，其中包含一个标识符：c</li></ol> <p>执行console.log时，并查找a,b,c三个变量的引用，首先从最内部的作用域，也就是bar函数作用域开始查找，引擎无法在这里找到a, 因此会去上一级foo的作用域中继续查找，在这里找到了a，因此就使用这个a。</p> <p>查找作用域的二个原则：</p> <ol><li>作用域查找从运行时所处的最内部作用域开始，逐级向外</li> <li>作用域会在找到第一个匹配的标识符时停止</li></ol> <h3 id="再理解词法作用域">再理解词法作用域</h3> <p>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的，编译的词法分析阶段基本上能够知道全部的标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它进行查找</p> <p>通过示例代码来说明：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token punctuation">}</span>

funtion <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a  <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>a 的查找过程是：</p> <ol><li>现在foo中找，找不到</li> <li>到foo的上层作用域找，<strong>注意 foo 的上层作用域是全局作用域</strong>，而不是bar，因为foo函数定义在全局（此时已经确定了查找规则），bar中只是调用了foo函数而已</li></ol> <p>词法作用域让foo()中的a引用到了全局作用域中的a, 因此会打印2</p> <h3 id="千呼万唤始出来">千呼万唤始出来</h3> <p>这门语言中一个非常重要但又难于掌握，近乎神话的概念：闭包</p> <p>下面我们来看一段代码，清晰地展示了闭包</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

  funcion <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> bar<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> baz <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2, 这就是闭包的效果</span>
</code></pre></div><p>函数bar()的词法作用域能够访问foo()的内部作用域，然而我们将bar函数本身当作一个值类型进行传递，在foo()执行后，其返回值（也就是内部的bar()函数）赋值给变量baz并调用baz()，bar()显然可以被执行，但是在这个例子中，它在自己定义的词法作用域 <em>以外</em> 的地方执行</p> <p>在foo() 执行后，通常会期待foo()的整个内部作用域被销毁，因此我们知道引擎有垃圾回收机制用来释放不再使用的内存，由于看上去foo()的内容不会再被使用，所以很自然的考虑会对其进行回收。</p> <p>而闭包的 “神奇” 之处正是可以阻止这件事情的发生，事实上内部作用域依然存在，因此没有被回收，谁在使用这个内部作用域呢？原来是bar()在使用</p> <p>bar()依然保持着对改作用域的引用，而这个引用就叫闭包</p> <h3 id="犹抱琵琶半遮面">犹抱琵琶半遮面</h3> <p>前面的代码为了解释如何使用闭包而人为的在结构上进行修饰，实际上闭包绝不仅仅那么的好玩，现在来搞懂下面的事实</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token constant">IIFE</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 2</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>虽然这段代码可以正常执行，但严格来讲它并不是闭包，为什么？因为函数（IIFE()）并不是在它本身的词法作用域外执行</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div></div></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.8cad83db.js" defer></script><script src="/assets/js/4.ec535a3a.js" defer></script><script src="/assets/js/8.ca727292.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.0/prism.min.js"></script>
  </body>
</html>